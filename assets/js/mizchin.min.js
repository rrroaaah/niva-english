// Mizoon Theme Scripts
// Auto-generated file


// File: alert\alert-need\script.js


// File: alert\alert-successful\script.js


// File: article\script.js


// File: baner-mobile\script.js



// File: biography\script.js


// File: button-date\script.js
class ButtonDate {
    constructor (){
        const choices = document.querySelectorAll(".choices");
        choices.forEach(choice => {
            const btnDates = choice.querySelectorAll(".button-date");

            btnDates.forEach(btnDate => {
                btnDate.addEventListener("click", () => {
                    btnDates.forEach(btnDateDelActive => {
                        btnDateDelActive.classList.remove("active");
                        btnDate.classList.add("active");
                    });
                });
            });
        });
    }
}
new ButtonDate();

// File: card-brand\script.js


// File: card-tooltip\script.js


// File: certificate-of-appreciation\script.js


// File: comments-like\script.js
class CommentLike {
  constructor(element) {
    this.container = element;

    this.positiveBtn = this.container.querySelector(".positive");
    this.negativeBtn = this.container.querySelector(".negative");

    this.positiveCountEl = this.positiveBtn.querySelector(".count");
    this.negativeCountEl = this.negativeBtn.querySelector(".count");

    this.positiveCount = parseInt(this.positiveCountEl.textContent);
    this.negativeCount = parseInt(this.negativeCountEl.textContent);

    this.state = null;

    this.init();
  }

  init() {
    this.positiveBtn.addEventListener("click", () => this.handleClick("positive"));
    this.negativeBtn.addEventListener("click", () => this.handleClick("negative"));
  }

  handleClick(type) {
    if (this.state === type) {
      this.removeVote(type);
      this.resetStyles();
      this.state = null;
    } else {
      if (this.state) {
        this.removeVote(this.state);
      }

      this.resetStyles();
      this.addVote(type);
      this.applyStyle(type);
      this.state = type;
    }
  }

  addVote(type) {
    if (type === "positive") {
      this.positiveCount++;
      this.positiveCountEl.textContent = this.positiveCount;
    } else {
      this.negativeCount++;
      this.negativeCountEl.textContent = this.negativeCount;
    }
  }

  removeVote(type) {
    if (type === "positive") {
      this.positiveCount--;
      this.positiveCountEl.textContent = this.positiveCount;
    } else {
      this.negativeCount--;
      this.negativeCountEl.textContent = this.negativeCount;
    }
  }

  applyStyle(type) {
    if (type === "positive") {
      this.positiveBtn.classList.add("active");
    } else {
      this.negativeBtn.classList.add("active");
    }
  }

  resetStyles() {
    this.positiveBtn.classList.remove("active");
    this.negativeBtn.classList.remove("active");
  }
}
document.querySelectorAll(".like-box").forEach(box => {
  new CommentLike(box);
});

// File: commodity-pack\script.js


// File: contact-us\script.js


// File: copy\script.js
class CopyAddress {
    constructor(selector = '.copy-address') {
      this.items = document.querySelectorAll(selector);
      this.init();
    }
  
    init() {
      this.items.forEach(wrapper => {
        const copyBtn = wrapper.querySelector('.copy-item');
        const urlEl = wrapper.querySelector('.site-url');
  
        if (!copyBtn || !urlEl) return;
  
        const url = window.location.href;
  
        urlEl.textContent = url;
  
        copyBtn.addEventListener('click', () => {
          this.copyToClipboard(url, copyBtn);
        });
      });
    }
  
    copyToClipboard(text, button) {
      navigator.clipboard.writeText(text).then(() => {
        this.onSuccess(button);
      }).catch(() => {
        this.onError(button);
      });
    }
  
  }
  
new CopyAddress();

// File: countdown\script.js
class Countdown {
  static UNITS = ['seconds', 'minutes', 'hours', 'days'];
  static DEFAULT_SEPARATOR = ':';
  static INTERVAL = 1000;

  constructor(element, options = {}) {
    this.element = element;
    this.separator = options.separator || Countdown.DEFAULT_SEPARATOR;
    this.parts = (element.dataset.countdown || '0').split(':').map(Number).reverse();
    this.unitCount = this.parts.length;
    this.totalSeconds = this.toSeconds(this.parts);
    this.timer = null;

    this.build();
    this.start();
  }

  // --- Helpers ---
  toSeconds([seconds = 0, minutes = 0, hours = 0, days = 0]) {
    return seconds + minutes * 60 + hours * 3600 + days * 86400;
  }

  fromSeconds(total) {
    const limits = [60, 60, 24, Infinity];
    return limits.map(limit => {
      const value = total % limit;
      total = Math.floor(total / limit);
      return value;
    });
  }

  createSeparator() {
    const sep = document.createElement('span');
    sep.className = 'countdown-separator';
    sep.textContent = this.separator;
    return sep;
  }

  createItem(value, unit) {
    const item = document.createElement('div');
    item.className = `countdown-item ${unit}`;
    String(value).padStart(2, '0').split('').forEach(digit => {
      const span = document.createElement('span');
      span.className = 'fields';
      span.textContent = digit;
      item.appendChild(span);
    });
    return item;
  }

  // --- Build DOM ---
  build() {
    this.element.innerHTML = '';
    this.parts.forEach((value, index) => {
      const unit = Countdown.UNITS[index];
      if (!unit) return;
      this.element.appendChild(this.createItem(value, unit));
      if (index < this.unitCount - 1) this.element.appendChild(this.createSeparator());
    });
  }

  // --- Update DOM ---
  update(values) {
    this.element.querySelectorAll('.countdown-item').forEach((item, index) => {
      String(values[index]).padStart(2, '0').split('').forEach((digit, i) => {
        item.querySelectorAll('.fields')[i].textContent = digit;
      });
    });
  }

  // --- Timer ---
  tick() {
    if (this.totalSeconds <= 0) {
      clearInterval(this.timer);
      return;
    }
    this.totalSeconds--;
    this.update(this.fromSeconds(this.totalSeconds));
  }

  start() {
    this.timer = setInterval(() => this.tick(), Countdown.INTERVAL);
  }

  pause() {
    clearInterval(this.timer);
    this.timer = null;
  }

  resume() {
    if (!this.timer) this.start();
  }
}

// Auto-init
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.countdown[data-countdown]').forEach(el => new Countdown(el));
});


// File: devicebanner\script.js


// File: dropdown\script.js
class Dropdown {
    constructor() {
        this.init();
    }

    init() {
        document.querySelectorAll('.dropdown').forEach(dropdown => {
            this.setupDropdown(dropdown);
        });
    }

    setupDropdown(dropdown) {
        const box = dropdown.querySelector('.dropdown-box');
        const menu = dropdown.querySelector('.dropdown-menu');
        const submenus = dropdown.querySelectorAll('.dropdown-submenu');
        const isHoverEnabled = dropdown.classList.contains('dropdown-hover') || 
            (menu && menu.classList.contains('dropdown-hover'));

        if (!isHoverEnabled) {
            box.addEventListener('click', (e) => {
                e.stopPropagation();
                this.toggle(dropdown);
            });
        }

        submenus.forEach(submenu => {
            const toggle = submenu.querySelector('.dropdown-submenu-toggle');

            if (!isHoverEnabled && toggle) {
                toggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.toggleSubmenu(submenu);
                });
            }

            submenu.addEventListener('mouseenter', () => {
                if (window.innerWidth > 768 && isHoverEnabled) {
                    this.openSubmenu(submenu);
                }
            });

            submenu.addEventListener('mouseleave', () => {
                if (window.innerWidth > 768 && isHoverEnabled) {
                    this.closeSubmenu(submenu);
                }
            });
        });

        if (!isHoverEnabled) {
            document.addEventListener('click', (e) => {
                if (!dropdown.contains(e.target)) {
                    this.close(dropdown);
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    this.close(dropdown);
                }
            });
        }
    }

    toggle(dropdown) {
        if (dropdown.classList.contains('active')) {
            this.close(dropdown);
        } else {
            this.open(dropdown);
        }
    }

    open(dropdown) {
        document.querySelectorAll('.dropdown.active').forEach(d => {
            if (d !== dropdown) d.classList.remove('active');
        });
        dropdown.classList.add('active');
    }

    close(dropdown) {
        dropdown.classList.remove('active');
        dropdown.querySelectorAll('.dropdown-submenu').forEach(sub => {
            this.closeSubmenu(sub);
        });
    }

    toggleSubmenu(submenu) {
        if (submenu.classList.contains('active')) {
            this.closeSubmenu(submenu);
        } else {
            this.openSubmenu(submenu);
        }
    }

    openSubmenu(submenu) {
        const siblings = Array.from(submenu.parentElement.children)
            .filter(child => child !== submenu && child.classList.contains('dropdown-submenu'));
        siblings.forEach(sib => this.closeSubmenu(sib));
        submenu.classList.add('active');
    }

    closeSubmenu(submenu) {
        submenu.classList.remove('active');
        submenu.querySelectorAll('.dropdown-submenu').forEach(child => {
            this.closeSubmenu(child);
        });
    }
}

new Dropdown();

// File: faq\script.js
class Accordion {
    constructor() {
        this.accordionItems = document.querySelectorAll('.accordion');
        this.init();
    }

    init() {
        this.accordionItems.forEach(item => {
            this.accordionHeader = item.querySelector('.accordion-header');
            this.accordionHeader.addEventListener('click', (event) => this.handleAccordionClick(event));
            // item.addEventListener('click', (event) => this.handleAccordionClick(event));
        });
    }

    handleAccordionClick(event) {
        const clickedItem = event.currentTarget;
        const parentElement = clickedItem.parentElement;
        const siblings = parentElement.querySelectorAll('.accordion');

        if (this.isIndependent(clickedItem)) {
            this.toggleAccordion(clickedItem);
            return;
        }

        this.closeOtherAccordions(siblings, clickedItem);
        this.toggleAccordion(clickedItem);
    }

    isIndependent(item) {
        return item.classList.contains('accordion-absolute');
    }

    toggleAccordion(item) {
        item.classList.toggle('active');
    }

    closeOtherAccordions(siblings, currentItem) {
        siblings.forEach(sibling => {
            if (sibling !== currentItem && !this.isIndependent(sibling)) {
                sibling.classList.remove('active');
            }
        });
    }
}

// Initialize accordion when DOM is loaded
new Accordion();

// File: feature-description-box\script.js
let featureDescriptionBoxes = document.querySelectorAll(".feature-description-box");

featureDescriptionBoxes.forEach(featureDescriptionBox => {
    let description = featureDescriptionBox.querySelector(".description");
    description.addEventListener("click", () => {
        description.classList.remove("ellipsis-4");
    });
});

// File: forign-product\script.js


// File: like-buttton\script.js
class LikeBtn {
    constructor(selector, options = {}) {
        const containers = document.querySelectorAll(selector);
        if (!containers.length) return;

        containers.forEach((item) => {
            const countEl = item.querySelector(".count");
            if (!countEl) return;

            let value = parseInt(countEl.textContent) || 0;

            item.addEventListener("click", () => {
                const isActive = item.classList.contains("active");

                if (isActive) {
                    value--;
                    item.classList.remove("active");
                } else {
                    value++;
                    item.classList.add("active");
                }
                countEl.textContent = value;
            });
        });
    }
}

new LikeBtn(".like-comment");

// File: payment-details\script.js


// File: popup-cart\script.js


// File: popup-share\script.js


// File: popup-video\script.js


// File: product-button-feature\script.js


// File: product-card\script.js
document.addEventListener('DOMContentLoaded', () => {
    const cartLikeBtn = document.querySelectorAll('.feature.checkpay');

    cartLikeBtn.forEach(item => {
        item.addEventListener('click', () => {
          item.classList.toggle('active');
        });
    });
  
});

// File: product-category\script.js
const productsCategory = document.querySelectorAll(".product-category");

productsCategory.forEach(category => {
    category.addEventListener("click" , () => {
        productsCategory.forEach(active => active.classList.remove("active"));

        category.classList.add("active");
    });
});

// File: product-comment\script.js


// File: product-details\script.js


// File: product-gallery-slider\script.js
class ProductHover {
    constructor(selector = '.product-gallery .slider-content') {
      this.items = document.querySelectorAll(selector);
      this.init();
    }
  
    init() {
      this.items.forEach(wrapper => {
        const img = wrapper.querySelector('img');
        if (!img) return;
  
        wrapper.addEventListener('mousemove', e => {
          this.onMove(e, wrapper, img);
        });
  
        wrapper.addEventListener('mouseleave', () => {
          this.onLeave(img);
        });
      });
    }
  
    onMove(e, wrapper, img) {
      const rect = wrapper.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;
  
      img.style.transformOrigin = `${x}% ${y}%`;
      img.style.transform = 'scale(2)';
    }
  
    onLeave(img) {
      img.style.transformOrigin = 'center';
      img.style.transform = 'scale(1)';
    }
}

new ProductHover();

// File: product-qa\script.js


// File: product-specifications\script.js


// File: product-toolbar\script.js
document.addEventListener('DOMContentLoaded', () => {
  const toolbar = document.querySelector('.product-toolbar');
  if (!toolbar) return;

  const likeBtn = toolbar.querySelector('.label.like');
  if (!likeBtn) return;

  likeBtn.addEventListener('click', () => {
    likeBtn.classList.toggle('is-active');
  });
});


// File: progress\script.js
class ProgressBar {
    constructor() {
        this.init();
    }

    init() {
        document.querySelectorAll('.progress-bar').forEach(bar => {
            const percentage = bar.dataset.progressPercentage;
            const duration = bar.dataset.progressDuration;
            const delay = bar.dataset.progressDelay;

            if (percentage) {
                bar.style.setProperty('--percentage', percentage);
            }

            if (duration) {
                bar.style.setProperty('--progress-animation-duration', duration);
            }

            if (delay) {
                bar.style.setProperty('--progress-animation-delay', delay);
            }
        });
    }
}

new ProgressBar();

// File: qty\script.js
class Quantity {
	constructor(selector, options = {}) {
		this.plusBtns = document.querySelectorAll(".qty-plus");
		this.minusBtns = document.querySelectorAll(".qty-minus");
		if (!this.plusBtns || !this.minusBtns) return;

		this.init();
	}

	init() {
		let self = this;

		this.plusBtns.forEach(function (btn) {
			let valueInput = btn.nextElementSibling;
			let min = valueInput.getAttribute("min");
			valueInput.value = min;
            
			btn.addEventListener("click", () => self.increment(valueInput));
			valueInput.addEventListener("change", () => self.setValue(valueInput));
            valueInput.addEventListener("keydown", function(event){
                if (event.key == "ArrowUp"){
                    self.increment(valueInput);
                }
                else if (event.key == "ArrowDown"){
                    self.decrement(valueInput);
                }
            });
		});

		this.minusBtns.forEach(function (btn) {
			let valueInput = btn.previousElementSibling;
			let min = valueInput.getAttribute("min");
			valueInput.value = min;
			btn.addEventListener("click", () => self.decrement(valueInput));
			valueInput.addEventListener("change", () => self.setValue(valueInput));
		});
	}

	increment(valueInput) {
		let max = valueInput.getAttribute("max");

		if (Number(valueInput.value) < Number(max)) {
			valueInput.value = Number(valueInput.value) + 1;
		}
        // window.addEventListener("keydown", function(event){
        //     if (event.key == ""){

        //     }
        // });
	}

	decrement(valueInput) {
		let min = valueInput.getAttribute("min");

		if (Number(valueInput.value) > Number(min)) {
			valueInput.value = Number(valueInput.value) - 1;
		}
        // window.addEventListener("keydown", function(event){
        //     if (event.key == ""){

        //     }
        // });
	}

    setValue(valueInput){
        let max = Number(valueInput.getAttribute("max"));
		let min = Number(valueInput.getAttribute("min"));
        valueInput.value = Number(valueInput.value);
        
        if (valueInput.value > max){
            valueInput.value = max;
        }
        else if (valueInput.value < min){
            console.log(valueInput.value , min);
            valueInput.value = min;
        }
    }
}

new Quantity(".qty");


// File: range-slider\script.js
class DualRangeSlider {
    constructor(config = {}) {
        this.settings = {
            locale: config.locale || 'en',
            selectors: {
                rangeSlider: config.selectors?.rangeSlider || '.range-slider',
                inputMin: config.selectors?.inputMin || '.range-slider .range-wrapper .range-min',
                inputMax: config.selectors?.inputMax || '.range-slider .range-wrapper .range-max',
                displayMin: config.selectors?.displayMin || '.range-slider .values .value-min',
                displayMax: config.selectors?.displayMax || '.range-slider .values .value-max',
                progressBar: config.selectors?.progressBar || '.range-slider .range-progress'
            }
        };

        this.elements = this._initElements();
        if (!this._validateElements()) return;

        const dataGap = this.elements.rangeSlider?.dataset.rangeSliderGap;
        this.settings.minGap = dataGap ? parseInt(dataGap) : (config.minGap || 0);
        this.handleSliderInput = this.handleSliderInput.bind(this);
        this.handleTextInput = this.handleTextInput.bind(this);
        this.handleTextBlur = this.handleTextBlur.bind(this);
        
        this.init();
    }

    _initElements() {
        const s = this.settings.selectors;
        return {
            rangeSlider: document.querySelector(s.rangeSlider),
            inputMin: document.querySelector(s.inputMin),
            inputMax: document.querySelector(s.inputMax),
            displayMin: document.querySelector(s.displayMin),
            displayMax: document.querySelector(s.displayMax),
            progressBar: document.querySelector(s.progressBar)
        };
    }

    _validateElements() {
    const missing = Object.values(this.elements).filter(el => el === null);

    if (missing.length > 0) {
        console.warn('DualRangeSlider: Some elements were not found.', missing);
        // به جای خطا، فقط این متد رو رد می‌کنیم
        return false;
    }

    return true;
}

    init() {
        this.elements.inputMin.addEventListener('input', this.handleSliderInput);
        this.elements.inputMax.addEventListener('input', this.handleSliderInput);
        
        this.elements.displayMin.addEventListener('input', this.handleTextInput);
        this.elements.displayMax.addEventListener('input', this.handleTextInput);
        
        this.elements.displayMin.addEventListener('blur', this.handleTextBlur);
        this.elements.displayMax.addEventListener('blur', this.handleTextBlur);

        this.updateUI();
    }

    handleSliderInput(e) {
        this._enforceGapConstraint(e.target);
        this.updateUI();
    }

    handleTextInput(e) {
        const target = e.target;
        const rawValue = target.value.replace(/[^0-9]/g, '');
        let val = parseInt(rawValue);
        
        if (isNaN(val)) return;

        const isMin = target === this.elements.displayMin;
        const sliderToUpdate = isMin ? this.elements.inputMin : this.elements.inputMax;
        const otherSlider = isMin ? this.elements.inputMax : this.elements.inputMin;
        
        const maxVal = parseInt(sliderToUpdate.max);
        const minVal = parseInt(sliderToUpdate.min);
        const gap = this.settings.minGap;

        let finalVal = Math.max(minVal, Math.min(maxVal, val));

        if (isMin) {
            if (finalVal > parseInt(otherSlider.value) - gap) {
                finalVal = parseInt(otherSlider.value) - gap;
            }
        } else {
            if (finalVal < parseInt(otherSlider.value) + gap) {
                finalVal = parseInt(otherSlider.value) + gap;
            }
        }

        sliderToUpdate.value = finalVal;
        this._updateProgressBar();
        target.value = this._formatNumber(finalVal);
    }

    handleTextBlur(e) {
        const target = e.target;
        const sliderVal = parseInt(target === this.elements.displayMin ? this.elements.inputMin.value : this.elements.inputMax.value);
        target.value = this._formatNumber(sliderVal);
    }

    _enforceGapConstraint(activeInput) {
        let val1 = parseInt(this.elements.inputMin.value);
        let val2 = parseInt(this.elements.inputMax.value);
        const gap = this.settings.minGap;

        if (val2 - val1 < gap) {
            if (activeInput === this.elements.inputMin) {
                this.elements.inputMin.value = val2 - gap;
            } else {
                this.elements.inputMax.value = val1 + gap;
            }
        }
    }

    updateUI() {
        const val1 = parseInt(this.elements.inputMin.value);
        const val2 = parseInt(this.elements.inputMax.value);

        const isMinFocused = document.activeElement === this.elements.displayMin;
        const isMaxFocused = document.activeElement === this.elements.displayMax;

        if (!isMinFocused) {
            this.elements.displayMin.value = this._formatNumber(val1);
        }
        if (!isMaxFocused) {
            this.elements.displayMax.value = this._formatNumber(val2);
        }

        this._updateProgressBar();
    }

    _updateProgressBar() {
        const val1 = parseInt(this.elements.inputMin.value);
        const val2 = parseInt(this.elements.inputMax.value);
        const percent1 = (val1 / this.elements.inputMin.max) * 100;
        const percent2 = (val2 / this.elements.inputMax.max) * 100;

        this.elements.progressBar.style.left = percent1 + "%";
        this.elements.progressBar.style.width = (percent2 - percent1) + "%";
    }

    _formatNumber(num) {
        let formatted = num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");

        if (this.settings.locale === 'fa') {
            const farsiDigits = ['۰', '۱', '۲', '۳', '۴', '۵', '۶', '۷', '۸', '۹'];
            formatted = formatted.replace(/\d/g, x => farsiDigits[x]);
        }

        return formatted;
    }
}

new DualRangeSlider({locale: 'en'});

// File: rating-card\script.js


// File: register-comment-box\script.js
class StarsFull {
    constructor(){
        const stars = document.querySelectorAll('.stars-full');
        stars.forEach((star) => {
          const dataStar = star.dataset.starsWidth;
          star.style.width = dataStar;
        });
    }
}
new StarsFull();

// File: return-conditions\script.js


// File: single-product-content\script.js
class SectionScroller {
	constructor(options) {
		this.upArrow = document.querySelector(options.upArrowSelector);
		this.downArrow = document.querySelector(options.downArrowSelector);
		this.titles = document.querySelectorAll(options.titleSelector);
		this.sections = options.sectionIds.map((id) => document.getElementById(id));
		this.currentIndex = 0;

		this.init();
	}

	init() {
		this.updateTitle(this.currentIndex);
		this.bindEvents();
	}

	bindEvents() {
		if (!this.upArrow || !this.downArrow) return;

		this.upArrow.addEventListener("click", () => this.scrollToSection(this.currentIndex - 1));

		this.downArrow.addEventListener("click", () => this.scrollToSection(this.currentIndex + 1));

		window.addEventListener("scroll", () => this.onScroll());
	}

	updateTitle(index) {
		this.titles.forEach((h3, i) => h3.classList.toggle("active", i === index));
	}

	scrollToSection(index) {
		if (index < 0) index = 0;
		if (index >= this.sections.length) index = this.sections.length - 1;

		this.sections[index].scrollIntoView({ behavior: "smooth" });
		this.currentIndex = index;
		this.updateTitle(this.currentIndex);
	}

	onScroll() {
		const scrollPos = window.scrollY + window.innerHeight / 2;
		this.sections.forEach((section, idx) => {
			if (section.offsetTop <= scrollPos) {
				this.currentIndex = idx;
				this.updateTitle(this.currentIndex);
			}
		});
	}
}

document.addEventListener("DOMContentLoaded", () => {
	const scroller = new SectionScroller({
		upArrowSelector: ".arrow-controls .fa-angle-up",
		downArrowSelector: ".arrow-controls .fa-angle-down",
		titleSelector: ".slider-frame h3",
		sectionIds: ["description-link", "description-completed", "comented-link", "question-link"],
	});
});


// File: sliders\brand-swiper\script.js
// قبل از init Swiper، المنت رو چک می‌کنیم
const bannerSwiperEl = document.querySelector(".banner-card-content");

if (bannerSwiperEl) {
  new Swiper(".banner-card-content", {
    loop: true,
    spaceBetween: 0,
    grabCursor: true,

    pagination: {
      el: ".swiper-pagination",
      clickable: true, 
      dynamicBullets: true,
    },

    navigation: {
      nextEl: ".swiper-button-next",
      prevEl: ".swiper-button-prev",
    }, 

    breakpoints: { 
      1: { slidesPerView: 3 },
      576: { slidesPerView: 4 },
      768: { slidesPerView: 6 },
      992: { slidesPerView: 8 },
      1200: { slidesPerView: 10 },
      1400: { slidesPerView: 12 }  
    },
  });
} else {
  console.warn('Swiper: ".banner-card-content" not found, slider init skipped.');
}

// File: sliders\offer-product-swiper\script.js
document.querySelectorAll(".offer-card-content").forEach((el) => {
  new Swiper(el, {
    loop: true,
    spaceBetween: 32,
    grabCursor: true,

    pagination: {
      el: el.closest(".card-container").querySelector(".swiper-pagination"),
      clickable: true,
      dynamicBullets: true,
    },

    navigation: {
      nextEl: el.closest(".card-container").querySelector(".swiper-button-next"),
      prevEl: el.closest(".card-container").querySelector(".swiper-button-prev"),
    },

    breakpoints: {
      0: { slidesPerView: 3 },
      576: { slidesPerView: 3 },
      768: { slidesPerView: 3 },
      992: { slidesPerView: 3 },
      1200: { slidesPerView: 4 },
      1400: { slidesPerView: 4 },
    },
  });
});


// File: sliders\simple-product-swiper\script.js
document.querySelectorAll(".card-content").forEach((el) => {
  new Swiper(el, {
    loop: true,
    spaceBetween: 32,
    grabCursor: true,

    pagination: {
      el: el.closest(".card-container").querySelector(".swiper-pagination"),
      clickable: true,
      dynamicBullets: true,
    },

    navigation: {
      nextEl: el.closest(".card-container").querySelector(".swiper-button-next"),
      prevEl: el.closest(".card-container").querySelector(".swiper-button-prev"),
    },

    breakpoints: {
      0: { slidesPerView: 1 },
      576: { slidesPerView: 2 },
      768: { slidesPerView: 3 },
      992: { slidesPerView: 3 },
      1200: { slidesPerView: 4 },
      1400: { slidesPerView: 4 },
    },
  });
});


// File: sliders\slider\script.js
class Slider {
    constructor(selector = ".slider") {
        this.instances = [];
        document.querySelectorAll(selector).forEach(slider => {
            this.instances.push(this.createInstance(slider));
        });
    }

    createInstance(slider) {
        const instance = {
            container: slider,
            wrapper: slider.querySelector(".slider-wrapper"),
            track: slider.querySelector(".slider-container"),
            slides: Array.from(slider.querySelectorAll(".slider-content")),
            toggles: slider.querySelectorAll(".slider-toggle"),
            nextArrows: slider.querySelectorAll(".slider-arrow-next"),
            prevArrows: slider.querySelectorAll(".slider-arrow-prev"),

            current: 0,
            startX: 0,
            startY: 0,
            isDragging: false,
            autoplayTimer: null,
            pointerId: null,

            clickStartX: 0,
            clickStartY: 0,

            isVertical: false,
            isLoop: false,
            isDraggable: false,
            isRTL: false,
            autoplayDelay: null,

            init() {
                this.isVertical = this.container.classList.contains("slider-column");
                this.isLoop = this.container.classList.contains("slider-loop");
                this.isDraggable = this.container.classList.contains("slider-draggable");
                this.isRTL = getComputedStyle(this.container).direction === "rtl";

                this.autoplayDelay = this.container.dataset.sliderTimer ? parseInt(this.container.dataset.sliderTimer) : null;

                const activeIndex = this.slides.findIndex(s => s.classList.contains("active"));
                this.current = activeIndex >= 0 ? activeIndex : 0;

                this.bindEvents();
                this.update();
                this.initAutoplay();
            },

            /* ---------- core ---------- */
            update() {
                let value = this.current * 100;
                if (this.isVertical || !this.isRTL) value *= -1;

                this.track.style.transform = this.isVertical
                    ? `translateY(${value}%)`
                    : `translateX(${value}%)`;

                this.slides.forEach(s => s.classList.remove("active"));
                if(this.slides[this.current]) this.slides[this.current].classList.add("active");

                this.toggles.forEach(t => t.classList.remove("active"));
                const t = this.container.querySelector(`.slider-toggle[data-slider-id="${this.slides[this.current]?.id}"]`);
                t?.classList.add("active");

                this.updateArrows();
            },

            updateArrows() {
                if (!this.prevArrows || !this.nextArrows || this.isLoop) return;

                this.prevArrows.forEach(prevArrow => {
                    prevArrow.classList.toggle("disabled", this.current === 0);
                });
                this.nextArrows.forEach(nextArrow => {
                    nextArrow.classList.toggle("disabled", this.current === this.slides.length - 1);
                });
            },

            next() {
                if (this.current < this.slides.length - 1) this.current++;
                else if (this.isLoop) this.current = 0;
                this.update();
            },
            prev() {
                if (this.current > 0) this.current--;
                else if (this.isLoop) this.current = this.slides.length - 1;
                this.update();
            },

            goTo(target) {
                if (typeof target === "number") {
                    this.current = target;
                } else {
                    const slide = document.getElementById(target);
                    this.current = this.slides.indexOf(slide);
                }
                this.update();
            },

            /* ---------- drag / touch ---------- */
            onStart(e) {
                e.preventDefault(); 
                
                this.isDragging = true;
                this.pointerId = e.pointerId;
                
                this.startX = e.clientX;
                this.startY = e.clientY;
                this.clickStartX = e.clientX;
                this.clickStartY = e.clientY;

                this.track.style.transition = "none";
                this.wrapper.classList.add("dragging");

                this.wrapper.setPointerCapture(e.pointerId);

                this.slides.forEach(s => {
                    s.querySelectorAll("img").forEach(img => img.setAttribute("draggable", "false"));
                });

                this.stopAutoplay();
            },

            onMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();

                let diff;
                if (this.isVertical) {
                    diff = this.startY - e.clientY;
                    this.track.style.transform = `translateY(calc(${this.current * -100}% - ${diff}px))`;
                } else {
                    diff = this.startX - e.clientX;
                    const sign = this.isRTL ? -1 : 1;
                    this.track.style.transform = `translateX(calc(${this.current * -100 * sign}% - ${diff}px))`;
                }
            },

            onEnd(e) {
                if (!this.isDragging) return;

                this.wrapper.releasePointerCapture(e.pointerId);

                let diff;
                if (this.isVertical) {
                    diff = this.startY - e.clientY;
                } else {
                    diff = this.startX - e.clientX;
                }

                const moveDist = Math.hypot(e.clientX - this.clickStartX, e.clientY - this.clickStartY);
                const isClick = moveDist < 5;

                this.track.style.transition = "";
                this.isDragging = false;
                this.wrapper.classList.remove("dragging");

                this.slides.forEach(s => {
                    s.querySelectorAll("img").forEach(img => img.setAttribute("draggable", "true"));
                });

                if (Math.abs(diff) > 50) {
                    let sign;
                    this.isRTL || this.isVertical ? sign = diff < 0 : sign = diff > 0;
                    sign ? this.next() : this.prev();
                } else {
                    this.update();
                }

                this.initAutoplay();
                
                if (isClick) {
                    const target = document.elementFromPoint(e.clientX, e.clientY);
                    if (target) {
                        const clickEvent = new MouseEvent('click', {
                            view: window,
                            bubbles: true,
                            cancelable: true
                        });
                        target.dispatchEvent(clickEvent);
                    }
                }
            },

            /* ---------- autoplay ---------- */
            initAutoplay() {
                if (!this.autoplayDelay) return;
                this.stopAutoplay();
                this.autoplayTimer = setInterval(() => this.next(), this.autoplayDelay * 1000);
            },

            stopAutoplay() {
                if (this.autoplayTimer) clearInterval(this.autoplayTimer);
            },

            /* ---------- events ---------- */
            bindEvents() {
                this.nextArrows.forEach(nextArrow => {
                    nextArrow?.addEventListener("click", () => this.next());
                });
                this.prevArrows.forEach(prevArrow => {
                    prevArrow?.addEventListener("click", () => this.prev());
                });

                this.toggles.forEach(toggle => {
                    toggle.addEventListener("click", () =>
                        this.goTo(toggle.dataset.sliderId)
                    );
                });

                if (this.isDraggable){
                    this.wrapper.addEventListener("pointerdown", (e) => this.onStart(e));
                    this.wrapper.addEventListener("pointermove", (e) => this.onMove(e));
                    this.wrapper.addEventListener("pointerup", (e) => this.onEnd(e));
                    this.wrapper.addEventListener("pointercancel", (e) => this.onEnd(e));
                }

                this.container.addEventListener("focus" , () => {
                    window.addEventListener("keydown", e => {
                        if (e.key === "ArrowRight") this.isRTL ? this.prev() : this.next();
                        if (e.key === "ArrowLeft") this.isRTL ? this.next() : this.prev();
                    });
                });
            },

            /* ---------- public api ---------- */
            getCurrentIndex() {
                return this.current;
            },

            getCurrentSlide() {
                return this.slides[this.current];
            },

            destroy() {
                this.stopAutoplay();
                this.track.style.transform = "";
            }
        };

        instance.init();
        return instance;
    }

    /* global api */
    next() {
        this.instances.forEach(i => i.next());
    }
    prev() {
        this.instances.forEach(i => i.prev());
    }
    goTo(v) {
        this.instances.forEach(i => i.goTo(v));
    }
}

new Slider();

// File: sliders\story-swiper\script.js
document.querySelectorAll(".story-container").forEach((el) => {
  new Swiper(el, {
    loop: true,
    spaceBetween: 0,
    grabCursor: true,

    pagination: {
      el: el.closest(".card-container").querySelector(".swiper-pagination"),
      clickable: true,
      dynamicBullets: true,
    },

    navigation: {
      nextEl: el.closest(".card-container").querySelector(".swiper-button-next"),
      prevEl: el.closest(".card-container").querySelector(".swiper-button-prev"),
    },

    breakpoints: {
      0: { slidesPerView: 6 },
      576: { slidesPerView: 6 },
      768: { slidesPerView: 8 },
      992: { slidesPerView: 8 },
      1200: { slidesPerView: 10 },
      1400: { slidesPerView: 13 },  
    },
  });
});


// File: sort-by\script.js
class SortBy {
    static initAll() {
        document.querySelectorAll('.sort-by').forEach(el => {
            new SortBy(el);
        });
    }

    constructor(container) {
        this.container = container;
        this.items = container.querySelectorAll('li');
        this.activeClass = 'active';

        this.bind();
    }

    bind() {
        this.items.forEach(item => {
            item.addEventListener('click', () => {
                this.items.forEach(i =>
                    i.classList.remove(this.activeClass)
                );
                item.classList.add(this.activeClass);
            });
        });
    }
}

document.addEventListener('DOMContentLoaded', () => {
    SortBy.initAll();
});
 

// File: story\card\script.js


// File: story\script.js
new LikeBtn(".story-content .like-story");

class StoryTimeLine {
    constructor() {
            const slider = document.querySelectorAll(".story-modal .slider");

            slider.forEach((slid) => {

            const timer = slid.dataset.sliderTimer;
            if (timer) {
                slid.style.setProperty('--timer-time-line', `${timer}s`);
            }
        });
    }
}

new StoryTimeLine();

// File: story\toggle\script.js


// File: suggestion\script.js


// File: summary-opinion\script.js


// File: switcher\script.js
class Switcher {
    constructor() {
        const switchers = document.querySelectorAll(".switcher");
        if (!switchers.length) return;
        switchers.forEach((switcher) => {
            switcher.addEventListener("click", () => {
                switcher.classList.toggle("active");
            });
        });
    }
}

new Switcher();



// File: topseller\script.js


// File: unavailable-product\script.js


// File: variable-product\script.js
class variableProduct {
  constructor() {
    this.variableProducts = document.querySelectorAll('.product-wrapper-sticky');
    this.descriptionHeader = document.querySelector('.description-header');
    
    this.lastScroll = 0;
    this.offset = 100;
    this.init();
  } 

  init() {
    if (this.variableProducts.length === 0 || !this.descriptionHeader) return;
    
    window.addEventListener('scroll', () => this.onScroll());
  }

  onScroll() {
    const currentScroll = window.pageYOffset || document.documentElement.scrollTop;
    
    if (currentScroll > this.lastScroll && currentScroll > this.offset) {
      this.hide();
    } else {
      this.show();
    }
    
    this.lastScroll = currentScroll <= 0 ? 0 : currentScroll;
  }

  hide() {
    this.variableProducts.forEach(element => {
      element.style.top = "6rem";
    });
    this.descriptionHeader.style.top = "5.6rem";
  }

  show() {
    this.variableProducts.forEach(element => {
      element.style.top = "10rem";
    });
    this.descriptionHeader.style.top = "9.6rem";
  }
}

new variableProduct();


// File: weblog-card\script.js

